## Inner Classes

An inner class is a non-static nested class. It has access to all members (properties, functions, etc.) of its outer class. This tight coupling is useful for creating helper classes that are logically tied to the behavior of the outer class.

Inner classes help encapsulate functionality within a single class, which can improve code organization and readability.

### Memory Leak
A memory leak occurs because an inner class holds an implicit reference to its outer class. If a long-lived object (like a `static` reference in a companion object) holds a reference to the inner class instance, it will also indirectly hold a reference to the outer class instance (e.g., an `Activity`). This prevents the outer class from being garbage collected, even after it has been destroyed.

| Inner class | Normal (static) nested class |
| --- | --- |
| ![Screenshot 2023-02-01 at 7 35 23 PM](https://user-images.githubusercontent.com/2602891/216132199-11dd0d20-17d6-4f5a-916f-e89104e6e887.png) |![Screenshot 2023-02-01 at 7 34 09 PM](https://user-images.githubusercontent.com/2602891/216131872-9948ae33-7a71-45cd-9cf8-1a2fdc5a1504.png) |

By default, nested classes in Kotlin are static. To create an inner class, you must use the `inner` keyword.
You can verify this by inspecting the generated bytecode:
**Tools > Kotlin > Show Kotlin Bytecode > Decompile**

| Inner class bytecode (contains a reference to the outer class) | Normal nested class bytecode (is static) |
| --- | --- |
|![Screenshot 2023-02-01 at 7 47 19 PM](https://user-images.githubusercontent.com/2602891/216134958-5789b673-f991-43bd-95ca-910863e1a032.png) |![Screenshot 2023-02-01 at 7 44 43 PM](https://user-images.githubusercontent.com/2602891/216134313-c747f709-dde8-4802-bcef-cb138de7c47b.png) |

### Memory Leak Example

In the following example, `InnerClass` is an inner class of `InnerClassActivity`. In `onCreate`, we create an instance of `InnerClass` and store it in a `static` companion object property. When the device is rotated, the `InnerClassActivity` is destroyed, but the `static` `innerClass` reference lives on. Because `innerClass` instance holds an implicit reference back to the destroyed `Activity`, it cannot be garbage collected, causing a memory leak.

```kotlin
class InnerClassActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_leak)

        // Assigning the inner class instance to a static variable
        // creates a leak. The instance holds a reference to the Activity.
        innerClass = InnerClass()
    }

    // This inner class has an implicit reference to InnerClassActivity.
    inner class InnerClass {
        fun printMessage() {
            println("Hello from the inner class!")
        }
    }

    companion object {
        // This static reference will outlive the Activity instance,
        // causing a memory leak.
        private lateinit var innerClass: InnerClass
    }
}
```

**To see the leak:**
1. Run the app and open the Android Studio Profiler.
2. Force garbage collection and capture a heap dump.
3. Rotate the device to trigger an Activity recreation.
4. Force garbage collection again and capture a second heap dump.
5. Inspect the heap dump to find the leaked `InnerClassActivity` instance.

| Old Android studio                                                                                                                                                                                                                                         | New Android studio                                                                                                                           | 
|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------|
| <img width="334" alt="Screenshot 2023-02-01 at 8 03 07 PM" src="https://user-images.githubusercontent.com/2602891/216139722-d2060e5b-d066-408a-ae66-5de58793bf0d.png">   <br/>  Run “Force garbage collection” then select “Capture heap dump” and start record |![leak_in_AS.png](../media/leak_in_AS.png)|
* The heap dump output
![inner_class_example_1_heapdump.png](../media/inner_class_example_1_heapdump.png)

### Fixing the Leak: Use a Static Nested Class

To fix this leak, you must break the implicit reference from the inner class to the outer class. You can do this by making the class a **static nested class**—simply remove the `inner` keyword.

A static nested class does not hold an implicit reference to its outer class, so a static reference to it will not leak the outer class instance.

**Before (Leaky):**
```kotlin
inner class InnerClass { ... }
```

**After (Fixed):**
```kotlin
class FixedClass { ... }
```